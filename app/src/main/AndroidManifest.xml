package com.prodestino.manaus

import android.Manifest
import android.annotation.SuppressLint
import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.net.ConnectivityManager
import android.net.Network
import android.net.http.SslError
import android.os.Build
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.os.PowerManager
import android.provider.Settings
import android.view.View
import android.view.WindowInsets
import android.view.WindowInsetsController
import android.webkit.CookieManager
import android.webkit.GeolocationPermissions
import android.webkit.SslErrorHandler
import android.webkit.WebChromeClient
import android.webkit.WebResourceError
import android.webkit.WebResourceRequest
import android.webkit.WebResourceResponse
import android.webkit.WebSettings
import android.webkit.WebView
import android.webkit.WebViewClient
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import com.prodestino.manaus.location.ForegroundLocationService

class MainActivity : AppCompatActivity() {

    private lateinit var webView: WebView

    // Flags de estado para evitar loops
    private var bootCompletedOnce = false
    private var resumed = false

    private val ui = Handler(Looper.getMainLooper())

    // Conectividade
    private var cm: ConnectivityManager? = null
    private val netCb = object : ConnectivityManager.NetworkCallback() {
        override fun onAvailable(network: Network) {
            // Internet voltou: se estiver na página offline, volta para o site; senão, dá reload
            ui.post {
                if (!this@MainActivity::webView.isInitialized) return@post
                val url = webView.url ?: ""
                val startUrl = startUrl()
                if (url.startsWith("file:///android_asset/")) {
                    webView.loadUrl(startUrl)
                } else {
                    // evita loop em POSTs — só recarrega páginas GET do site
                    if (url.startsWith("https://")) webView.reload()
                }
            }
        }
    }

    // ===== Helpers de permissão =====
    private fun hasFineOrCoarse(): Boolean {
        val fine = ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED
        val coarse = ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) == PackageManager.PERMISSION_GRANTED
        return fine || coarse
    }

    private fun hasNotifPermission(): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            ContextCompat.checkSelfPermission(this, Manifest.permission.POST_NOTIFICATIONS) == PackageManager.PERMISSION_GRANTED
        } else true
    }

    // ===== Launchers =====
    private val reqForegroundPerms = registerForActivityResult(
        ActivityResultContracts.RequestMultiplePermissions()
    ) {
        proceedIfReady()
    }

    private val reqNotifPerm = registerForActivityResult(
        ActivityResultContracts.RequestPermission()
    ) {
        proceedIfReady()
    }

    // Pede SOMENTE localização foreground (evita travas)
    private fun ensureForegroundLocationOnce() {
        if (!hasFineOrCoarse()) {
            reqForegroundPerms.launch(
                arrayOf(
                    Manifest.permission.ACCESS_FINE_LOCATION,
                    Manifest.permission.ACCESS_COARSE_LOCATION
                )
            )
        }
    }

    // Pede POST_NOTIFICATIONS apenas quando já temos localização OK
    private fun ensureNotificationPermIfNeeded() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU && !hasNotifPermission()) {
            reqNotifPerm.launch(Manifest.permission.POST_NOTIFICATIONS)
        }
    }

    /**
     * Centro do fluxo: só avança quando:
     *  - activity em primeiro plano (resumed == true),
     *  - localização foreground OK,
     *  - (Android 13+) notificação OK.
     */
    private fun proceedIfReady() {
        if (!resumed) return
        if (!hasFineOrCoarse()) return
        if (!hasNotifPermission()) {
            ensureNotificationPermIfNeeded()
            return
        }

        if (!bootCompletedOnce) {
            bootCompletedOnce = true
            // Pequeno atraso evita crash de alguns OEMs ao iniciar serviço cedo demais
            ui.postDelayed({
                initWebViewIfNeeded()
                startTrackingServiceSafely()
            }, 350L)
        }
    }

    // ===== Cookie do WebView → SharedPreferences =====
    private fun saveWebCookie(cookie: String?) {
        if (!cookie.isNullOrBlank()) {
            getSharedPreferences("app_prefs", MODE_PRIVATE)
                .edit()
                .putString("web_cookie", cookie)
                .apply()
        }
    }

    private fun startUrl(): String =
        BuildConfig.BASE_URL.ifBlank { "https://manaus.prodestino.com" }

    @SuppressLint("SetJavaScriptEnabled")
    private fun initWebViewIfNeeded() {
        if (this::webView.isInitialized && webView.url != null) return

        webView = WebView(this)
        setContentView(webView)
        applyImmersive() // esconde barras

        val s = webView.settings
        s.javaScriptEnabled = true
        s.domStorageEnabled = true
        s.databaseEnabled = true
        s.setGeolocationEnabled(true) // necessário para navigator.geolocation
        s.mixedContentMode = WebSettings.MIXED_CONTENT_NEVER_ALLOW
        s.mediaPlaybackRequiresUserGesture = false
        s.userAgentString = s.userAgentString + " ProDestinoWebView/1.0"

        CookieManager.getInstance().setAcceptCookie(true)
        CookieManager.getInstance().setAcceptThirdPartyCookies(webView, true)

        // ==== BLOCO COM TRATAMENTO DE ERROS (offline/404/SSL) ====
        webView.webViewClient = object : WebViewClient() {

            private fun showOffline() {
                // evita loop se já estamos na página local
                if (webView.url?.startsWith("file:///android_asset/") == true) return
                webView.loadUrl("file:///android_asset/offline.html")
            }

            override fun shouldOverrideUrlLoading(view: WebView, request: WebResourceRequest): Boolean {
                val uri = request.url
                val host = uri.host ?: return false
                // corrige hosts terminando com ponto
                if (host.endsWith(".")) {
                    val fixed = Uri.Builder()
                        .scheme(uri.scheme ?: "https")
                        .encodedAuthority(host.trimEnd('.'))
                        .encodedPath(uri.encodedPath)
                        .encodedQuery(uri.encodedQuery)
                        .build()
                        .toString()
                    view.loadUrl(fixed)
                    return true
                }
                return false
            }

            // HTTP 4xx/5xx (apenas no frame principal)
            override fun onReceivedHttpError(
                view: WebView,
                request: WebResourceRequest,
                errorResponse: WebResourceResponse
            ) {
                if (request.isForMainFrame && errorResponse.statusCode >= 400) {
                    showOffline()
                }
            }

            // Falhas de rede (sem internet, timeout, DNS…)
            override fun onReceivedError(
                view: WebView,
                request: WebResourceRequest,
                error: WebResourceError
            ) {
                if (request.isForMainFrame) showOffline()
            }

            // Erros SSL (cert inválido, data/hora errada…)
            override fun onReceivedSslError(
                view: WebView,
                handler: SslErrorHandler,
                error: SslError
            ) {
                handler.cancel()
                showOffline()
            }

            override fun onPageFinished(view: WebView, url: String) {
                super.onPageFinished(view, url)
                // Captura cookie da base para o serviço
                try {
                    val base = startUrl().trimEnd('/')
                    val cookie = CookieManager.getInstance().getCookie(base)
                    saveWebCookie(cookie)
                } catch (_: Exception) { /* ignore */ }
            }
        }
        // ==== FIM DO BLOCO DE TRATAMENTO DE ERROS ====

        webView.webChromeClient = object : WebChromeClient() {
            override fun onGeolocationPermissionsShowPrompt(
                origin: String?, callback: GeolocationPermissions.Callback?
            ) {
                // Só autoriza se o app já tem FINE/COARSE e o origin é o seu domínio
                val allow = hasFineOrCoarse() && origin?.startsWith("https://manaus.prodestino.com") == true
                callback?.invoke(origin, allow, false)
                if (!allow && !hasFineOrCoarse()) {
                    ensureForegroundLocationOnce()
                }
            }
        }

        webView.loadUrl(startUrl())
    }

    private fun startTrackingServiceSafely() {
        try {
            ForegroundLocationService.start(this)
        } catch (_: Throwable) {
            ui.postDelayed({
                try { ForegroundLocationService.start(this) } catch (_: Throwable) {}
            }, 1000L)
        }
    }

    // ===== Modo imersivo (esconde status + navegação) =====
    private fun applyImmersive() {
        val win = window
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            val ic = win.insetsController ?: return
            ic.hide(WindowInsets.Type.statusBars() or WindowInsets.Type.navigationBars())
            ic.systemBarsBehavior =
                WindowInsetsController.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE
        } else {
            @Suppress("DEPRECATION")
            win.decorView.systemUiVisibility =
                View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY or
                View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN or
                View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION or
                View.SYSTEM_UI_FLAG_FULLSCREEN or
                View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
        }
    }

    // ===== Ciclo de vida =====
    @SuppressLint("SetJavaScriptEnabled")
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // Monitora rede para sair da tela offline quando reconectar
        cm = getSystemService(CONNECTIVITY_SERVICE) as ConnectivityManager
        try { cm?.registerDefaultNetworkCallback(netCb) } catch (_: Exception) {}

        // Não carrega a WebView ainda; primeiro resolvemos as permissões
        ensureForegroundLocationOnce()
        askIgnoreBatteryOptimizations()
    }

    override fun onResume() {
        super.onResume()
        resumed = true
        applyImmersive() // garante imersivo ao voltar foco
        proceedIfReady()
    }

    override fun onWindowFocusChanged(hasFocus: Boolean) {
        super.onWindowFocusChanged(hasFocus)
        if (hasFocus) applyImmersive()
    }

    override fun onPause() {
        super.onPause()
        resumed = false
    }

    override fun onDestroy() {
        super.onDestroy()
        try { cm?.unregisterNetworkCallback(netCb) } catch (_: Exception) {}
    }

    override fun onBackPressed() {
        if (this::webView.isInitialized && webView.canGoBack()) webView.goBack()
        else super.onBackPressed()
    }

    private fun askIgnoreBatteryOptimizations() {
        try {
            val pm = getSystemService(POWER_SERVICE) as PowerManager
            val pkg = packageName
            if (!pm.isIgnoringBatteryOptimizations(pkg)) {
                val i = Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS).apply {
                    data = Uri.parse("package:$pkg")
                }
                startActivity(i)
            }
        } catch (_: Exception) { /* ignore */ }
    }
}
